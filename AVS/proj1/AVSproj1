1. 
a) Jaké je maximální dosažitelné zrychlení celého běhu kodéru, jestli se soustředíme na
optimalizaci nejzásadnějších konvolučních funkcí (v Bottom-up zobrazení by se mělo
jednat o 7 vrchních záznamů)? Výpočet lze v realizovat dle Amdahlova zákona.

maximalni dosazene zrychleni
S = doba výpočtu bez použití zlepšení / doba výpočtu při použití zlepšení
funkce automaticky vektorizovane z convolve.c s vyuzitim souboru optrpt:
7 nejvíce pomalých funkcí dle Bottom-Up a jejich možná zrychlení získaná ze souborů .optrpt:
funkce                     estimated potential speedup
av1_dist_wtd_convolve_2d_c 	4.530
av1_convolve_2d_sr_c 		4.530
av1_dist_wtd_convolve_x_c 	4.530
celkem zrychleni: 		13.59

b) Jaké je dle vás realisticky dosažitelné zrychlení (nebude přihlíženo na kvalitu vašeho
odhadu)?
Reálné zrychlení bude dle mého názoru nižší, protože ze souboru .optrpt se jedná pouze o přibližný odhad. A obecně Amdahlův zákon uvažuje maximální možné zrychlení, čili ideální podmínky.


c) Ze získaných optimalizačních reportů vypište nejméně 3 příčiny, které brání kompilátoru kód vektorizovat. Nemusíte se omezovat na konkrétní funkce.

LOOP BEGIN at /home/training/dd-20-28-39/aom/aom_dsp/aom_convolve.c(43,5) inlined into /home/training/dd-20-28-39/aom/aom_dsp/aom_convolve.c(95,3)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed ANTI dependence between x_filter[k] (25:41) and dst[x] (47:7)

LOOP BEGIN at /home/training/dd-20-28-39/aom/aom_dsp/aom_convolve.c(176,3) inlined into /home/training/dd-20-28-39/aom/aom_dsp/aom_convolve.c(215,3)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

LOOP BEGIN at /home/training/dd-20-28-39/aom/aom_dsp/aom_convolve.c(155,3) inlined into /home/training/dd-20-28-39/aom/aom_dsp/aom_convolve.c(201,3)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive


2. 
a) Proč kompilátoru (ve všeobecnosti) vadí překrytí filtru a cílového pole?
Překryv mu vadí, protože nedokáže určit, zda se pole nepřekrývají (pointer aliasing).
b) Co komplikuje vektorizaci horizontální konvoluce na úrovni smyčky ve směru x? Co
zhoršuje vektorizaci na úrovni smyčky ve směru y?
Horizontalni konvoluce na urovni x - Existence zavislosti mezi iteracemi
      Na urovni y - Pouzivani bitovych operaci pro deleni indexu
c) Který směr konvoluce (horizontální nebo vertikální) se vám povedlo urychlit (více)? V
čem je zásadní rozdíl mezi těmito kernely?
Urychlení horizontální konvoluce - z 2.24 s na 1.32 s - zrychlení o 0.92
Urychlení vertikální konvoluce - z 2.905 s na 1.645 s - zrychlení o 1.26

Vertikální konvoluci se mi podařila urychlit více. Zásadní rozdíl je v postupu procházení 2D pole. U vertikální procházíme po řádcích, u horizontální po sloupcích. A obecně je procházení po sloupcích nevýhodné při přístupu do paměti (výpadky).

3. 
a) Povedlo se vektorizovat všechny vzniklé cykly ve funkci? Proč?
Vždy jsem se snažila vektorizovat pouze vnořené smyčky. Zde se vždy jednalo o smyčky ve směru y. Avšak vektorizace se vždy nezdařila. Samozřejmě v případech, kdy byla vektorizována vnitřní smyčka už nebyla vektorizována i vnější smyčka.

Avšak u vertikálního filtru není vektorizována smyčka ve směru y pro ukládání výsledků.

LOOP BEGIN at /home/training/dd-20-28-39/aom/av1/common/convolve.c(327,5)
      remark #15313: simd loop was not vectorized: unsupported data type
      remark #15552: loop was not vectorized with "simd"
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

b)
Otestujte dosažené zrychlení na videu rush hour, aby jste ověřili „přenositelnost” optimalizací na jiné video. Dosáhli jste stejných výsledků jako v případě videa park joy?

TO DO 


c) Jaké jsou výhody psaní „vektorizovatelného” a jinak paralelizovatelného kódu a využívaní kompilátoru oproti psaní v jazyce symbolických instrukcí nebo využívání intrinsic funkcí? (Pro inspiraci se podívejte např. do aom/av1/common/x86/).
Jaké jsou výhody psaní „vektorizovatelného” a jinak paralelizovatelného kódu a využívaní kompilátoru oproti psaní v jazyce symbolických instrukcí nebo využívání intrinsic funkcí? (Pro inspiraci se podívejte např. do aom/av1/common/x86/).

Vektorizovatelný nebo jinak paralezitovatelný kód je přenosný narozdíl od např. intristic funkcí. Samozřejmě využití intristic funkcí může být výkonově efektivní, ale taková výkonnost už je na úkor dobré přenositelnosti. Proto je paralizovatelný kód lépe přenosným a nezaměřujeme se pouze na konkrétní stroj, ale na široké využití a široké podmínky. Dále můžeme paralelizovatelný kód lépe optimalizovat, využít plánování instrukcí.


